# Multi-cycle CPU

由于一些指令可能需要花费非常长的时间，因此我们可以通过多周期 CPU，来避免 CPU 的单个时钟周期太长。

具体地，我们将 CPU 的一个指令分解成若干个微指令，而一个微指令，就是 FSM 的一个状态——FSM 的一个状态，对应一组控制信号。如下图所示：

<img src="https://gitlab.com/mtdickens1998/mtd-images/-/raw/main/img/2024/05/5_22_39_48_202405052239026.png" style="zoom:67%;" />

- 输入：opcode（以及 funct3/7）
- 输出：各个控制信号

和 single cycle CPU 的区别就是：这个 CPU 有状态，不是纯粹的组合逻辑，而是时序逻辑。

---

<img src="https://gitlab.com/mtdickens1998/mtd-images/-/raw/main/img/2024/05/5_23_57_4_202405052357199.png" style="zoom:67%;" />

---

不过，目前这种架构并不常用，因为每执行一个微指令，CPU 一般只会用到很少的单元——其他单元是空闲的，从而造成资源浪费。

# Pipeline CPU

<img src="https://gitlab.com/mtdickens1998/mtd-images/-/raw/main/img/2024/05/6_4_34_55_202405060434966.jpeg" alt="img" style="zoom: 67%;" />

如图，上面的设计，就好似”流水线“一般：

1. 不同步骤之间尽量分开
    - 除了最后一步（write back）和第二部（instruction decoding）需要共用 imem 以外（不过也是一读一写），都是分开的
2. 步骤之间需要传递一些信息。而这些信息使用锁存器进行记录。
    - i.e. 每个步骤可以产生一些信息，也需要使用一些信息。后面步骤可能会依赖本步骤产生的信息和之前步骤产生的信息，此时，我们就要将这些信息传下去。
    - e.g. PC 需要一直传到 EX 步骤（因为 `jalr` 需要用到），而 PC+4 需要一直传到最后（因为 `jal`, `jalr` 可能用到）

## Hazards

有三种 hazards: structure hazard, data hazard and control hazard.

下面内容来自 [Lab5: 流水线 CPU 设计](https://yuque.zju.edu.cn/trsrpp/ozl96b/igc1df)

### 3.1 流水线并行

若把执行一条指令的过程比作洗衣服的过程，那么单周期 CPU （上图） 和流水线 CPU （下图）的差别如下所示。

<img src="https://gitlab.com/mtdickens1998/mtd-images/-/raw/main/img/2024/05/7_23_46_10_202405072346816.png" style="zoom: 50%;" />

可以看到虽然细一件衣服的时间没有变，但是同时最多可以洗四件衣服，所以效率得到了大大的提高。对于 CPU 来说，从 pc 中存储的指令地址，一直到取出地址，进行计算，将数据存回 regfile 或者数据内存，这一条路径的延时非常长，若将其分成不同阶段，流水线的执行，每条指令执行的时间不变（甚至会变长一点），但是 CPU 会同时执行多条指令，所以运行的效率会得到很大的提升。

经典的五级流水线 CPU，分为如下五级：

- 取指（IF）：根据 pc 取出指令
- 译码（ID）：根据取出的指令进行译码，生成控制信号，取出操作数等。
- 执行（EX）：执行计算或者做比较的过程。
- 访存（MEM）：访问数据内存
- 写回（WB）：将计算结果写回 regfile。

### 3.2 流水线竞争

竞争或冲突是因为指令的执行由顺序变为并行执行，由于指令之间的一些依赖关系导致了并行执行的指令存在冲突，通常有以下三种冲突。

- 结构竞争：并行的指令需要使用同一结构。
- 数据竞争：需要等待前序的指令完成数据的读写才能执行。
- 控制竞争：分支和跳转指令后续执行的指令需要该条指令执行完成后才能决定。

通常解决流水线竞争的方式就是停顿（stall），即将产生冲突的指令以及之后的指令的执行都停止，等待引发冲突的指令执行完成再继续执行。但也有一些方式可以解决冲突，减少 stall 的时钟周期数。

### 3.3 结构竞争的解决方式

经典五级流水线中，结构冲突有以下两种。

- IF 级和 MEM 级都要访问内存，产生结构冲突。
- ID 级要读取 regfile，WB 级要写入 regfile。

解决的方式其实很简单：

- 访问内存的冲突，其实将数据内存和指令内存分开已经完美地解决了这个结构竞争，所以咱们实验其实不存在这个冲突。
- 对于读写 regfile 的冲突，若 regfile 使用上升沿写入，则对 regfile 的写入会在下一个时钟周期上升沿才完成，则在下一个时钟周期才能看见修改，我们可以使用 double bump 技术，即 regfile 使用下降沿写入，将一个时钟周期一分为二，前半个周期完成数据的写入，后半个周期完成数据的读取。即可完美解决这个冲突。

#### 3.3.1 Double bump 技术详解

假设 ID 和 WB 发生在同一 clock cycle，且 regFile是**上升沿写入**，那么在时钟上升沿瞬间：

1. 从 MEM 中传过来的 rd 以及 data 和 regWrite 从 EX/MEM 传到 MEM/WB
    - 但是，由于写入寄存器需要时间，因此，在上升沿瞬间，MEM/WB 的寄存器还保持旧的数据
2. regFile 根据**旧的 MEM/WB 的 regWrite 和 rd, data**，决定是否写入、写到哪里、写入什么

因此，rd 的数据，直到**下一个周期才有效**

---

但是，如果采用**下降沿写入**，那么在下降沿瞬间：

1. MEM/WB 的数据，早已经是新的数据了
2. regFile根据**新的 MEM/WB 的 regWrite 和 rd, data**，决定是否写入、写到哪里、写入什么

因此，rd 的数据，在**本周期的后半部分（i.e. 低电平部分）**就有效了。

由于 regFile 的读取数据是组合电路，因此，在本周期的后半部分，rs1 和 rs2 均有效。下一周期开始，ID/EX 的也是有效的。

---

一个具体的例子：

如下图所示：通过 stall 的方式，我成功避免了 ADD R1, R2, R3 和 SUB R4, R1, R5 产生冲突。

- 注意：由于采用了 double bump，我可以在一个周期内完成 write back 以及 instruction decode。因此，只需要隔两条指令即可。
    当然，如果没有 double bump，那么就必须隔三条指令。

<img src="https://gitlab.com/mtdickens1998/mtd-images/-/raw/main/img/2024/05/8_2_7_5_202405080207201.png" style="zoom:80%;" />

### 3.4 数据竞争的解决方式

数据竞争主要有以下三种类型：

- RAW：写后读
- WAR：读后写
- WAW：写后写

由于五级流水线也是顺序流水线，能保证在前序指令完成写入和读取后才进行写入，所以不存在后面两种数据竞争类型。（体系结构课程会学到的乱序流水线会存在这两种竞争，大家可以期待一下，确信）

CPU 中只有数据内存和 regfile 两个结构会涉及到写入操作，所以数据竞争主要发生在这两个结构中，又由于数据内存一次只能处理一条指令的操作，一条指令不可能同时读和写内存，且顺序流水线保证了执行的顺序，**所以对数据内存不会出现写后读的竞争。**

则写后读只会发生在寄存器的读写中，可以设想一下在 EX 级或者 MEM 级存在指令要修改某个寄存器，但它是 ID 级指令的一个源寄存器，此时若直接读取就只能读取到旧数据，而不是前序指令修改后写回的数据。

解决的方式主要为 forwarding，即前递。

#### 3.4.1 forwarding

虽然前序指令在 EX 级或 MEM 级，还没将计算结果写回 regfile，但其实计算结果已经出现在了数据通路中，此时只要将其传到 ID 级，通过多路选择器选择正确的结果作为 ID 级从 regfile 中读取到的源数据即可。（当然这个多路选择逻辑也可以在 EX 中实现，具体的逻辑大家可以自行梳理。）

需要注意，若同时需要从 EX 级和 MEM 级前递结果，则需要判断前递最新的数据，即 EX 级的指令是后序指令，其才是最新的值。

#### 3.4.2 load 导致的 stall

若此时 ID 级需要 forwarding EX 级写回目的寄存器的结果，但是此时 EX 级是一条 Load 指令，则还没读取到需要的结果，则此时 IF 和 ID 两级需要因为这个冲突停顿一个时钟周期，当 load 指令流动到 MEM 级，将数据读取出来后前递到 ID 级。这个停顿是无法避免的。若产生了这个停顿，则只需停止 IF 和 ID 两级的指令流动（保持相关寄存器的值不变），并将 EX 级的下一条指令设为无效指令即可。

当然还有一种情况的 Load 产生的 stall 是可以通过 forwarding 来解决的，就是 load 指令后面是一条 store 指令，且 store 指令会将刚刚读取到的数据写回数据内存中，这个时候可以将 MEM 中读取到的数据前递到 MEM 级写端前的正确位置，从而减少掉这一 stall。

**注意：** stall 需要由编译器本身引入 `nop`，而不是由 CPU 硬件实现

### 3.5 控制竞争的解决方式

控制竞争的解决方式主要是预测，预测分支跳转指令到底是跳转还是不跳转，主要有以下两种：

- predict taken：预测这条指令会发生跳转。
- predict not taken：预测这条指令不会发生跳转。

此处只解释 predict not taken 的实现方式，其实非常简单，IF 级中的 pc 正常 +4 即可，当 EX 级检测到这条指令需要跳转时，将原 IF 和 ID 级的指令设为无效指令，并将计算好的跳转目的地址在下一时钟周期写到 pc 中即可。



在其他指令集（如 MIPS）会有**延时槽**技术，理论分析上能在顺序流水线中实现很好的分支预测的效果，要打龙芯杯的同学可以自行搜索一下。

### 3.6 Datapath

<img src="https://gitlab.com/mtdickens1998/mtd-images/-/raw/main/img/2024/05/7_23_47_16_202405072347829.png" style="zoom: 80%;" />

如图，我们特别设置一个 forwarding unit，使得更加容易控制。

# Conclusion

<img src="https://gitlab.com/mtdickens1998/mtd-images/-/raw/main/img/2024/05/8_2_36_37_202405080236330.png"/>